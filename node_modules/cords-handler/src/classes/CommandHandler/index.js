const { Collection } = require("discord.js");
const fs = require("fs");
const ascii = require("ascii-table");
const ms = require("ms");
const { NONAME } = require("dns");
const talkedRecently = new Set();
let table = new ascii("Commands");

table.setHeading("Command", "Load Status");

class CordsHandler {
  constructor(client, chclient, options) {
    if (!chclient)
      throw new ReferenceError("Cords-Handler Client Must Be Supplied.");
    if (!client) throw new ReferenceError("Cannot Find Client.");
    else {
      this.client = client;
      this.options = options;
      this.chclient = chclient;
      this.client.commands = new Collection();
      this.client.aliases = new Collection();
    }
  }
  setOwners(owners, errormsg) {
    if (!owners) throw new ReferenceError("Enter The Owner IDs!");
    if (!Array.isArray(owners) === true)
      throw new ReferenceError("Owner IDs Must Be An Array!");
    if (!errormsg) throw new ReferenceError("Enter The Error Message!");
    else {
      this.owners = owners;
      this.errormsg = errormsg;
    }
    return this;
  }
  setCommandFolder(cmdfolder) {
    if (!cmdfolder) throw new ReferenceError("Cannot Find Command Folder.");
    else {
      this.cmdfolder = cmdfolder;
    }
    return this;
  }
  setPrefix(prefix) {
    if (!prefix) throw new ReferenceError("Cannot Find Prefix.");
    else {
      this.prefix = prefix;
    }
    return this;
  }
  setPrefix2(prefix2) {
    if (!prefix2) return;
    else {
      this.prefix2 = prefix2;
    }
    return this;
  }
  setPrefix3(prefix3) {
    if (!prefix3) return;
    else {
      this.prefix3 = prefix3;
    }
    return this;
  }
  setPrefix4(prefix4) {
    if (!prefix4) return;
    else {
      this.prefix4 = prefix4;
    }
    return this;
  }
  setPrefix5(prefix5) {
    if (!prefix5) return;
    else {
      this.prefix5 = prefix5;
    }
    return this;
  }

  loader() {
    let komutlar = fs.readdirSync(`${process.cwd()}/${this.cmdfolder}`);
    for (let kategori of komutlar) {
      let komuts = fs.readdirSync(
        `${process.cwd()}/${this.cmdfolder}/${kategori}`
      );
      for (let komut of komuts) {
        let pull = require(`${process.cwd()}/${
          this.cmdfolder
        }/${kategori}/${komut}`);
        if (pull.name) {
          this.client.commands.set(pull.name, pull);
          table.addRow(`${kategori}/${komut}`, `✅`);
        } else {
          let data = {
            command: `${kategori}/${komut}`,
            message: "Cannot Read name.",
          };
          this.chclient.emit("catchError", data);
          table.addRow(`${kategori}/${komut}`, `❌ Cannot Read name.`);
          continue;
        }
        if (pull.aliases && Array.isArray(pull.aliases))
          pull.aliases.forEach((alias) =>
            this.client.aliases.set(alias, pull.name)
          );
        if (pull.cooldown) {
          if (!pull.cooldownError) {
            throw new ReferenceError(
              "Please Supply An Cooldown Error! In:" + file
            );
          } else {
            this.cooldown = pull.cooldown;

            this.cooldownError = pull.cooldownError;
          }
        }
      }
    }
    console.log(table.toString());
    this.chclient.emit("commandsLoaded");
    this.client.on("message", async (message) => {
      var p = this.prefix;
      let p2;
      let p3;
      let p4;
      let p5;
      if (this.prefix2) p2 = this.prefix2;
      if (this.prefix3) p3 = this.prefix3;
      if (this.prefix4) p4 = this.prefix4;
      if (this.prefix5) p5 = this.prefix5;
      if (message.content.startsWith(p)) {
        const commandName = message.content
          .slice(p.length)
          .trim()
          .split(" ")[0];
        const args = message.content.slice(p.length).trim().split(" ").slice(1);
        const cmd =
          this.client.commands.get(commandName) ||
          this.client.commands.get(this.client.aliases.get(commandName));

        if (cmd) {
          if (this.owners) {
            if (!this.owners.includes(message.author.id))
              return message.channel.send(this.errormsg);
          }
          if (cmd.botPerms) {
            if (!message.guild.me.hasPermission(cmd.botPerms))
              return message.channel.send(cmd.botPermsError);
          }
          if (cmd.userPerms) {
            if (!message.member.hasPermission(cmd.userPerms))
              return message.channel.send(cmd.userPermsError);
          }
          let data = {
            user: message.author,
            channel: message.channel,
            command: commandName,
          };
          if (cmd.cooldown) {
            if (talkedRecently.has(`${message.author.id}_${commandName}`)) {
              return message.channel.send(this.cooldownError);
            } else {
              talkedRecently.add(message.author.id);
              setTimeout(() => {
                talkedRecently.delete(`${message.author.id}_${commandName}`);
              }, ms(this.cooldown));
              cmd.run(this.client, message, args);
              this.chclient.emit("commandUsed", data);
            }
          } else {
            cmd.run(this.client, message, args);
            this.chclient.emit("commandUsed", data);
          }
        }
        if (!cmd) {
          let data = {
            command: commandName,
            user: message.author,
            channel: message.channel,
          };
          this.chclient.emit("commandNotFound", data);
        }
      }

      if (message.content.startsWith(p2)) {
        const commandName = message.content
          .slice(p2.length)
          .trim()
          .split(" ")[0];
        const args = message.content
          .slice(p2.length)
          .trim()
          .split(" ")
          .slice(1);
        const cmd =
          this.client.commands.get(commandName) ||
          this.client.commands.get(this.client.aliases.get(commandName));

        if (cmd) {
          let data = {
            user: message.author,
            channel: message.channel,
            command: commandName,
          };
          if (this.owners) {
            if (!this.owners.includes(message.author.id))
              return message.channel.send(this.errormsg);
          }
          if (cmd.botPerms) {
            if (!message.guild.me.hasPermission(cmd.botPerms))
              return message.channel.send(cmd.botPermsError);
          }
          if (cmd.userPerms) {
            if (!message.member.hasPermission(cmd.userPerms))
              return message.channel.send(cmd.userPermsError);
          }
          if (cmd.cooldown) {
            if (talkedRecently.has(`${message.author.id}_${commandName}`)) {
              return message.channel.send(this.cooldownError);
            } else {
              talkedRecently.add(`${message.author.id}_${commandName}`);
              setTimeout(() => {
                talkedRecently.delete(`${message.author.id}_${commandName}`);
              }, ms(this.cooldown));
              cmd.run(this.client, message, args);
              this.chclient.emit("commandUsed", data);
            }
          } else {
            cmd.run(this.client, message, args);
            this.chclient.emit("commandUsed", data);
          }
        }
        if (!cmd) {
          let data = {
            command: commandName,
            user: message.author,
            channel: message.channel,
          };
          this.chclient.emit("commandNotFound", data);
        }
      }
      if (message.content.startsWith(p3)) {
        const commandName = message.content
          .slice(p3.length)
          .trim()
          .split(" ")[0];
        const args = message.content
          .slice(p3.length)
          .trim()
          .split(" ")
          .slice(1);
        const cmd =
          this.client.commands.get(commandName) ||
          this.client.commands.get(this.client.aliases.get(commandName));

        if (cmd) {
          let data = {
            user: message.author,
            channel: message.channel,
            command: commandName,
          };
          if (this.owners) {
            if (!this.owners.includes(message.author.id))
              return message.channel.send(this.errormsg);
          }
          if (cmd.botPerms) {
            if (!message.guild.me.hasPermission(cmd.botPerms))
              return message.channel.send(cmd.botPermsError);
          }
          if (cmd.userPerms) {
            if (!message.member.hasPermission(cmd.userPerms))
              return message.channel.send(cmd.userPermsError);
          }
          if (cmd.cooldown) {
            if (talkedRecently.has(`${message.author.id}_${commandName}`)) {
              return message.channel.send(this.cooldownError);
            } else {
              talkedRecently.add(`${message.author.id}_${commandName}`);
              setTimeout(() => {
                talkedRecently.delete(message.author.id);
              }, ms(this.cooldown));
              cmd.run(this.client, message, args);
              this.chclient.emit("commandUsed", data);
            }
          } else {
            cmd.run(this.client, message, args);
            this.chclient.emit("commandUsed", data);
          }
        }
        if (!cmd) {
          let data = {
            command: commandName,
            user: message.author,
            channel: message.channel,
          };
          this.chclient.emit("commandNotFound", data);
        }
      }
      if (message.content.startsWith(p4)) {
        const commandName = message.content
          .slice(p4.length)
          .trim()
          .split(" ")[0];
        const args = message.content
          .slice(p4.length)
          .trim()
          .split(" ")
          .slice(1);
        const cmd =
          this.client.commands.get(commandName) ||
          this.client.commands.get(this.client.aliases.get(commandName));

        if (cmd) {
          let data = {
            user: message.author,
            channel: message.channel,
            command: commandName,
          };
          if (this.owners) {
            if (!this.owners.includes(message.author.id))
              return message.channel.send(this.errormsg);
          }
          if (cmd.botPerms) {
            if (!message.guild.me.hasPermission(cmd.botPerms))
              return message.channel.send(cmd.botPermsError);
          }
          if (cmd.userPerms) {
            if (!message.member.hasPermission(cmd.userPerms))
              return message.channel.send(cmd.userPermsError);
          }
          if (cmd.cooldown) {
            if (talkedRecently.has(`${message.author.id}_${commandName}`)) {
              return message.channel.send(this.cooldownError);
            } else {
              talkedRecently.add(message.author.id);
              setTimeout(() => {
                talkedRecently.delete(`${message.author.id}_${commandName}`);
              }, ms(this.cooldown));
              cmd.run(this.client, message, args);
              this.chclient.emit("commandUsed", data);
            }
          } else {
            cmd.run(this.client, message, args);
            this.chclient.emit("commandUsed", data);
          }
        }
        if (!cmd) {
          let data = {
            command: commandName,
            user: message.author,
            channel: message.channel,
          };
          this.chclient.emit("commandNotFound", data);
        }
      }
      if (message.content.startsWith(p5)) {
        const commandName = message.content
          .slice(p5.length)
          .trim()
          .split(" ")[0];
        const args = message.content
          .slice(p5.length)
          .trim()
          .split(" ")
          .slice(1);
        const cmd =
          this.client.commands.get(commandName) ||
          this.client.commands.get(this.client.aliases.get(commandName));

        if (cmd) {
          let data = {
            user: message.author,
            channel: message.channel,
            command: commandName,
          };
          if (this.owners) {
            if (!this.owners.includes(message.author.id))
              return message.channel.send(this.errormsg);
          }
          if (cmd.botPerms) {
            if (!message.guild.me.hasPermission(cmd.botPerms))
              return message.channel.send(cmd.botPermsError);
          }
          if (cmd.userPerms) {
            if (!message.member.hasPermission(cmd.userPerms))
              return message.channel.send(cmd.userPermsError);
          }
          if (cmd.cooldown) {
            if (talkedRecently.has(`${message.author.id}_${commandName}`)) {
              return message.channel.send(this.cooldownError);
            } else {
              talkedRecently.add(`${message.author.id}_${commandName}`);
              setTimeout(() => {
                talkedRecently.delete(`${message.author.id}_${commandName}`);
              }, ms(this.cooldown));
              cmd.run(this.client, message, args);
              this.chclient.emit("commandUsed", data);
            }
          } else {
            cmd.run(this.client, message, args);
            this.chclient.emit("commandUsed", data);
          }
        }
        if (!cmd) {
          let data = {
            command: commandName,
            user: message.author,
            channel: message.channel,
          };
          this.chclient.emit("commandNotFound", data);
        }
      }
    });
  }
}
module.exports = CordsHandler;
